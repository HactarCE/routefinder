var searchIndex = JSON.parse('{\
"routefinder":{"doc":"","i":[[3,"Captures","routefinder","Captured params and wildcards",null,null],[3,"Match","","This struct represents the output of a successful …",null,null],[3,"Matches","","A set of all [<code>Match</code>]es. Most likely, you\'ll want to …",null,null],[3,"Route","","A parsed [<code>RouteSpec</code>] and associated handler",null,null],[3,"RouteSpec","","the internal representation of a route, containing both …",null,null],[3,"Router","","a router represents an ordered set of routes which can be …",null,null],[4,"Segment","","the internal representation of a parsed component of a …",null,null],[13,"Slash","","represented by a / in the route spec and matching one /",0,null],[13,"Dot","","represented by a . in the route spec and matching one . …",0,null],[13,"Exact","","represented by any free text in the route spec, this …",0,null],[13,"Param","","represented by :name, where name is how the capture will …",0,null],[13,"Wildcard","","represented by * in the spec, this will capture …",0,null],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"clone","","",0,[[],["segment",4]]],[11,"default","","",1,[[],["captures",3]]],[11,"default","","",6,[[]]],[11,"cmp","","",3,[[],["ordering",4]]],[11,"cmp","","",4,[[],["ordering",4]]],[11,"cmp","","",5,[[],["ordering",4]]],[11,"cmp","","",0,[[],["ordering",4]]],[11,"eq","","",3,[[]]],[11,"eq","","",4,[[]]],[11,"eq","","",5,[[["routespec",3]]]],[11,"ne","","",5,[[["routespec",3]]]],[11,"eq","","",0,[[["segment",4]]]],[11,"ne","","",0,[[["segment",4]]]],[11,"partial_cmp","","",3,[[],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",4,[[],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",5,[[],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",0,[[],[["option",4],["ordering",4]]]],[11,"deref","","",1,[[]]],[11,"deref","","",2,[[]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_from","","",5,[[["string",3]],["result",4]]],[11,"from_str","","",5,[[],["result",4]]],[11,"wildcard","","returns what the * wildcard matched, if any",1,[[],["option",4]]],[11,"get","","checks the list of params for a matching key",1,[[],["option",4]]],[11,"for_routes_and_path","","",2,[[]]],[11,"handler","","Returns a reference to the handler associated with this …",3,[[]]],[11,"captures","","Returns the [<code>Captures</code>] for this match",3,[[],["captures",3]]],[11,"definition","","the [<code>RouteSpec</code>] for this [<code>Route</code>]",4,[[],["routespec",3]]],[11,"handler","","borrow whatever handler T is contained in this route",4,[[]]],[11,"segments","","a slice of [<code>RouteSpec</code>] [<code>Segments</code>] that represents this …",4,[[]]],[11,"is_match","","performs the test of whether this route matches a given …",4,[[],[["option",4],["match",3]]]],[11,"new","","",5,[[["vec",3],["segment",4]]]],[11,"new","","Builds a new router",6,[[]]],[11,"add","","Adds a route to the router, accepting any type that …",6,[[],["result",4]]],[11,"matches","","Returns <em>all</em> of the matching routes for a given path. This …",6,[[],["matches",3]]],[11,"best_match","","Returns the single best route match as defined by the …",6,[[],[["option",4],["match",3]]]]],"p":[[4,"Segment"],[3,"Captures"],[3,"Matches"],[3,"Match"],[3,"Route"],[3,"RouteSpec"],[3,"Router"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);